#!/bin/bash
# Atherix Tunnel v9

SERVER="45.10.165.199"
USER="tunnel"
SSH_PORT=22

BASE="$HOME/.atherix-tunnel"
KEY="$BASE/.key"
PID="$BASE/pids"
PORTS="$BASE/ports"
LOG="$BASE/logs"

mkdir -p "$PID" "$LOG"

# SSH key
setup_key(){
if [ ! -f "$KEY" ]; then
cat>"$KEY"<<'KEY'
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
QyNTUxOQAAACBJEK7mHycRjc8BFmcqL7PjJFgcDaRhFaDPinB8fjS54wAAAJhiOSxDYjks
QwAAAAtzc2gtZWQyNTUxOQAAACBJEK7mHycRjc8BFmcqL7PjJFgcDaRhFaDPinB8fjS54w
AAAEAy5wkmy3eoL+/RPuv+kv0s473dRWyOCFmvTBUCLPn89EkQruYfJxGNzwEWZyovs+Mk
WBwNpGEVoM+KcHx+NLnjAAAAFXR1bm5lbC1yZXN0cmljdGVkLWtleQ==
-----END OPENSSH PRIVATE KEY-----
KEY
chmod 600 "$KEY"
fi
}

alive(){ kill -0 "$1" 2>/dev/null; }

# проверка remote порта
check_port(){
ssh -i "$KEY" \
-o StrictHostKeyChecking=no \
-o UserKnownHostsFile=/dev/null \
-p $SSH_PORT \
$USER@$SERVER "ss -tuln | grep -q :$1" >/dev/null 2>&1
return $?
}

start(){
port="$1"
setup_key

pid_file="$PID/$port.pid"
log="$LOG/$port.log"

# очистка
if [ -f "$pid_file" ]; then
pid=$(cat "$pid_file")
if alive "$pid"; then
echo "Already running"
return
else
rm -f "$pid_file"
fi
fi

echo "Checking VDS port..."

# если порт свободен → фиксированный
check_port "$port"
if [ $? -ne 0 ]; then
REMOTE="$port:localhost:$port"
echo "Port free → using $port"
else
# если занят → random
REMOTE="0:localhost:$port"
echo "Port busy → random"
fi

ssh -i "$KEY" \
-o StrictHostKeyChecking=no \
-o UserKnownHostsFile=/dev/null \
-o ServerAliveInterval=30 \
-o ServerAliveCountMax=3 \
-o ExitOnForwardFailure=yes \
-N -f \
-R $REMOTE \
$USER@$SERVER -p $SSH_PORT >"$log" 2>&1

sleep 3

pid=$(pgrep -f "ssh.*$SERVER.*$port" | head -1)
[ -z "$pid" ] && { echo "Fail"; return; }

echo "$pid" > "$pid_file"

# получить внешний порт
remote="$port"

if grep -q "Allocated port" "$log"; then
remote=$(grep "Allocated port" "$log" | awk '{print $3}' | tail -1)
fi

# сохранить
grep -v "^$port " "$PORTS" 2>/dev/null > "$PORTS.tmp"
echo "$port $remote" >> "$PORTS.tmp"
mv "$PORTS.tmp" "$PORTS"

echo
echo "Public: http://$SERVER:$remote"
}

list(){
[ ! -f "$PORTS" ] && { echo "No tunnels"; return; }

while read -r p r; do
pid_file="$PID/$p.pid"
if [ -f "$pid_file" ] && alive "$(cat "$pid_file")"; then
echo "Local $p → http://$SERVER:$r"
else
sed -i "/^$p /d" "$PORTS"
fi
done < "$PORTS"
}

stop(){
kill "$(cat "$PID/$1.pid" 2>/dev/null)" 2>/dev/null
rm -f "$PID/$1.pid"
sed -i "/^$1 /d" "$PORTS"
}

case "$1" in
[0-9]*) start "$1" ;;
list) list ;;
stop) stop "$2" ;;
*)
echo "Usage:"
echo "tunnel <port>"
echo "tunnel list"
echo "tunnel stop <port>"
;;
esac
