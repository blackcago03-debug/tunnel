#!/bin/bash
# AtherixCloud Tunnel v5 (Auto reconnect + auto restore)

SERVER="45.10.165.199"
USER="tunnel"
SSH_PORT=22

CONFIG_DIR="$HOME/.atherix-tunnel"
KEY_FILE="$CONFIG_DIR/.key"
LOG_DIR="$CONFIG_DIR/logs"
PID_DIR="$CONFIG_DIR/pids"
PORTS_FILE="$CONFIG_DIR/ports"

mkdir -p "$CONFIG_DIR" "$LOG_DIR" "$PID_DIR"
chmod 700 "$CONFIG_DIR"

RED="\e[31m"; GRN="\e[32m"; YEL="\e[33m"; CYN="\e[36m"; RST="\e[0m"

# SSH key
setup_key(){
if [ ! -f "$KEY_FILE" ];then
cat>"$KEY_FILE"<<'KEY'
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
QyNTUxOQAAACBJEK7mHycRjc8BFmcqL7PjJFgcDaRhFaDPinB8fjS54wAAAJhiOSxDYjks
QwAAAAtzc2gtZWQyNTUxOQAAACBJEK7mHycRjc8BFmcqL7PjJFgcDaRhFaDPinB8fjS54w
AAAEAy5wkmy3eoL+/RPuv+kv0s473dRWyOCFmvTBUCLPn89EkQruYfJxGNzwEWZyovs+Mk
WBwNpGEVoM+KcHx+NLnjAAAAFXR1bm5lbC1yZXN0cmljdGVkLWtleQ==
-----END OPENSSH PRIVATE KEY-----
KEY
chmod 600 "$KEY_FILE"
fi
}

# Проверка туннеля
tunnel_alive(){
pid="$1"
kill -0 "$pid" 2>/dev/null
}

# Проверка порта
check_remote_port(){
local port="$1"
ssh -i "$KEY_FILE" \
-o StrictHostKeyChecking=no \
-o UserKnownHostsFile=/dev/null \
-p $SSH_PORT \
$USER@$SERVER "ss -tuln | grep -q :$port" >/dev/null 2>&1
return $?
}

# Запуск
start_tunnel(){
local port="$1"
local pid_file="$PID_DIR/tunnel-$port.pid"
local log_file="$LOG_DIR/tunnel-$port.log"

setup_key

# Если туннель уже был
if [ -f "$pid_file" ];then
old_pid=$(cat "$pid_file")
if tunnel_alive "$old_pid"; then
echo -e "${GRN}Tunnel already running on $port${RST}"
return
else
echo -e "${YEL}Old tunnel dead → restarting${RST}"
rm -f "$pid_file"
fi
fi

# Проверка занят ли порт
check_remote_port "$port"
if [ $? -eq 0 ]; then
echo -e "${YEL}Port $port busy → random fallback${RST}"
REMOTE="0:localhost:$port"
else
REMOTE="$port:localhost:$port"
fi

ssh -i "$KEY_FILE" \
-o StrictHostKeyChecking=no \
-o UserKnownHostsFile=/dev/null \
-o ServerAliveInterval=30 \
-o ServerAliveCountMax=3 \
-o ExitOnForwardFailure=yes \
-N -f \
-R $REMOTE \
$USER@$SERVER \
-p $SSH_PORT \
>"$log_file" 2>&1

sleep 3

ssh_pid=$(pgrep -f "ssh.*$SERVER.*$port" | head -1)

if [ -n "$ssh_pid" ];then
echo "$ssh_pid" > "$pid_file"
grep -qx "$port" "$PORTS_FILE" 2>/dev/null || echo "$port" >> "$PORTS_FILE"
echo -e "${GRN}Tunnel active: $port${RST}"
else
echo -e "${RED}Failed${RST}"
fi
}

# Остановка
stop_tunnel(){
port="$1"
kill "$(cat "$PID_DIR/tunnel-$port.pid" 2>/dev/null)" 2>/dev/null
rm -f "$PID_DIR/tunnel-$port.pid"
sed -i "/^$port$/d" "$PORTS_FILE"
}

# Список
list_tunnels(){
cat "$PORTS_FILE" 2>/dev/null
}

# Восстановление после перезапуска
restore_tunnels(){
if [ ! -f "$PORTS_FILE" ];then
return
fi

while read -r port;do
start_tunnel "$port"
done < "$PORTS_FILE"
}

# Watchdog (авто reconnect)
watchdog(){
while true;do
sleep 20
while read -r port;do
pid_file="$PID_DIR/tunnel-$port.pid"
if [ -f "$pid_file" ];then
pid=$(cat "$pid_file")
if ! tunnel_alive "$pid";then
echo "Tunnel $port died → reconnect"
start_tunnel "$port"
fi
fi
done < "$PORTS_FILE" 2>/dev/null
done
}

# MAIN
case "$1" in
[0-9]*)
start_tunnel "$1"
;;
stop)
stop_tunnel "$2"
;;
list)
list_tunnels
;;
restore)
restore_tunnels
;;
watch)
watchdog
;;
*)
echo "Usage:"
echo "tunnel <port>"
echo "tunnel stop <port>"
echo "tunnel list"
echo "tunnel watch"
;;
esac
