#!/bin/bash
# Atherix Tunnel v6 (fixed list + random fallback + restore)

SERVER="45.10.165.199"
USER="tunnel"
SSH_PORT=22

CONFIG="$HOME/.atherix-tunnel"
KEY="$CONFIG/.key"
PID_DIR="$CONFIG/pids"
PORTS="$CONFIG/ports"
LOG="$CONFIG/logs"

mkdir -p "$PID_DIR" "$LOG"

# SSH key
setup_key(){
if [ ! -f "$KEY" ];then
cat>"$KEY"<<'KEY'
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
QyNTUxOQAAACBJEK7mHycRjc8BFmcqL7PjJFgcDaRhFaDPinB8fjS54wAAAJhiOSxDYjks
QwAAAAtzc2gtZWQyNTUxOQAAACBJEK7mHycRjc8BFmcqL7PjJFgcDaRhFaDPinB8fjS54w
AAAEAy5wkmy3eoL+/RPuv+kv0s473dRWyOCFmvTBUCLPn89EkQruYfJxGNzwEWZyovs+Mk
WBwNpGEVoM+KcHx+NLnjAAAAFXR1bm5lbC1yZXN0cmljdGVkLWtleQ==
-----END OPENSSH PRIVATE KEY-----
KEY
chmod 600 "$KEY"
fi
}

# Проверка жив ли
alive(){
kill -0 "$1" 2>/dev/null
}

# Проверка порта
check_port(){
ssh -i "$KEY" \
-o StrictHostKeyChecking=no \
-o UserKnownHostsFile=/dev/null \
-p $SSH_PORT \
$USER@$SERVER "ss -tuln | grep -q :$1" >/dev/null 2>&1
}

# Запуск
start(){
local port="$1"
local pid_file="$PID_DIR/$port.pid"
local log="$LOG/$port.log"

setup_key

# очистка старого
if [ -f "$pid_file" ];then
pid=$(cat "$pid_file")
if ! alive "$pid";then
rm -f "$pid_file"
else
echo "Already running"
return
fi
fi

# fallback
check_port "$port"
if [ $? -eq 0 ];then
REMOTE="0:localhost:$port"
else
REMOTE="$port:localhost:$port"
fi

ssh -i "$KEY" \
-o StrictHostKeyChecking=no \
-o UserKnownHostsFile=/dev/null \
-o ServerAliveInterval=30 \
-o ServerAliveCountMax=3 \
-o ExitOnForwardFailure=yes \
-N -f \
-R $REMOTE \
$USER@$SERVER -p $SSH_PORT \
>"$log" 2>&1

sleep 3

pid=$(pgrep -f "ssh.*$SERVER.*$port" | head -1)

if [ -z "$pid" ];then
echo "Failed"
return
fi

echo "$pid" > "$pid_file"

# получить внешний порт
if grep -q "Allocated port" "$log";then
remote=$(grep "Allocated port" "$log" | grep -oE '[0-9]{4,5}' | head -1)
else
remote="$port"
fi

# сохранить
grep -v "^$port " "$PORTS" 2>/dev/null > "$PORTS.tmp"
echo "$port $remote" >> "$PORTS.tmp"
mv "$PORTS.tmp" "$PORTS"

echo "Public: http://$SERVER:$remote"
}

# список
list(){
if [ ! -f "$PORTS" ];then
echo "No tunnels"
return
fi

while read -r port remote;do
pid_file="$PID_DIR/$port.pid"
if [ -f "$pid_file" ] && alive "$(cat "$pid_file")";then
echo "Local $port → http://$SERVER:$remote"
else
# авто очистка
sed -i "/^$port /d" "$PORTS"
fi
done < "$PORTS"
}

# стоп
stop(){
kill "$(cat "$PID_DIR/$1.pid" 2>/dev/null)" 2>/dev/null
rm -f "$PID_DIR/$1.pid"
sed -i "/^$1 /d" "$PORTS"
}

# восстановление
restore(){
while read -r port _;do
start "$port"
done < "$PORTS" 2>/dev/null
}

# watchdog
watch(){
while true;do
sleep 20
restore
done
}

# MAIN
case "$1" in
[0-9]*)
start "$1"
;;
list)
list
;;
stop)
stop "$2"
;;
watch)
watch
;;
*)
echo "Usage:"
echo "tunnel <port>"
echo "tunnel list"
echo "tunnel stop <port>"
;;
esac
