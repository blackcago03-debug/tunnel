#!/bin/bash
# Atherix Tunnel v10 (stable, no fail)

SERVER="45.10.165.199"
USER="tunnel"
SSH_PORT=22

BASE="$HOME/.atherix-tunnel"
KEY="$BASE/.key"
PID_DIR="$BASE/pids"
PORTS="$BASE/ports"
LOG_DIR="$BASE/logs"

mkdir -p "$PID_DIR" "$LOG_DIR"

# SSH key
setup_key(){
if [ ! -f "$KEY" ]; then
cat>"$KEY"<<'KEY'
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
QyNTUxOQAAACBJEK7mHycRjc8BFmcqL7PjJFgcDaRhFaDPinB8fjS54wAAAJhiOSxDYjks
QwAAAAtzc2gtZWQyNTUxOQAAACBJEK7mHycRjc8BFmcqL7PjJFgcDaRhFaDPinB8fjS54w
AAAEAy5wkmy3eoL+/RPuv+kv0s473dRWyOCFmvTBUCLPn89EkQruYfJxGNzwEWZyovs+Mk
WBwNpGEVoM+KcHx+NLnjAAAAFXR1bm5lbC1yZXN0cmljdGVkLWtleQ==
-----END OPENSSH PRIVATE KEY-----
KEY
chmod 600 "$KEY"
fi
}

alive(){ kill -0 "$1" 2>/dev/null; }

# проверка порта на VDS
check_port(){
ssh -i "$KEY" \
-o StrictHostKeyChecking=no \
-o UserKnownHostsFile=/dev/null \
-p $SSH_PORT \
$USER@$SERVER "ss -tuln | grep -q :$1" >/dev/null 2>&1
return $?
}

start(){
port="$1"
setup_key

pid_file="$PID_DIR/$port.pid"
log="$LOG_DIR/$port.log"

# очистка старого
if [ -f "$pid_file" ]; then
old=$(cat "$pid_file")
if alive "$old"; then
echo "Already running"
return
else
rm -f "$pid_file"
fi
fi

echo "Checking VDS..."

# fixed или random
check_port "$port"
if [ $? -ne 0 ]; then
REMOTE="$port:localhost:$port"
echo "Port free → $port"
else
REMOTE="0:localhost:$port"
echo "Port busy → random"
fi

# запуск ssh в фоне (стабильно)
ssh -i "$KEY" \
-o StrictHostKeyChecking=no \
-o UserKnownHostsFile=/dev/null \
-o ServerAliveInterval=30 \
-o ServerAliveCountMax=3 \
-o ExitOnForwardFailure=yes \
-N \
-R $REMOTE \
$USER@$SERVER -p $SSH_PORT >"$log" 2>&1 &

pid=$!
sleep 3

if ! alive "$pid"; then
echo "Fail"
return
fi

echo "$pid" > "$pid_file"

# получить внешний порт
remote="$port"

if grep -q "Allocated port" "$log"; then
remote=$(grep "Allocated port" "$log" | awk '{print $3}' | tail -1)
fi

# сохранить
grep -v "^$port " "$PORTS" 2>/dev/null > "$PORTS.tmp"
echo "$port $remote" >> "$PORTS.tmp"
mv "$PORTS.tmp" "$PORTS"

echo
echo "Public: http://$SERVER:$remote"
}

list(){
[ ! -f "$PORTS" ] && { echo "No tunnels"; return; }

while read -r p r; do
pid_file="$PID_DIR/$p.pid"
if [ -f "$pid_file" ] && alive "$(cat "$pid_file")"; then
echo "Local $p → http://$SERVER:$r"
else
sed -i "/^$p /d" "$PORTS"
fi
done < "$PORTS"
}

stop(){
kill "$(cat "$PID_DIR/$1.pid" 2>/dev/null)" 2>/dev/null
rm -f "$PID_DIR/$1.pid"
sed -i "/^$1 /d" "$PORTS"
}

case "$1" in
[0-9]*) start "$1" ;;
list) list ;;
stop) stop "$2" ;;
*)
echo "Usage:"
echo "tunnel <port>"
echo "tunnel list"
echo "tunnel stop <port>"
;;
esac
